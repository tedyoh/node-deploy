15장 AWS와 GCP로 배포하기

사전 작업이 마무리된 후에는 대표적인 클라우드 플랫폼인 
아마존 웹 서비스(Amazon Web Servise)(이하 AWS)와
구글 플라우드 플랫폼(Google Cloud Platform)(이하 GCP)에 
여러분의 서비스를 배포하는 방법을 배워보겠습니다. 

*****<1> 서비스 운영을 위하 패키지 *****
서비스를 개발하는 도중에는 서버에 문제가 생겨 서버가 꺼져도 큰 문제가 되지 않습니다. 
출시하기 전에 해결하면 되니깐요. 하지만 서비스를 출시한 이후에 서버에 문제가 생기면 
서비스 자체에 심각한 타격을 입습니다. 
또한, 서비스의 취약점을 노린 공격이 들어올 수도 있습니다. 
따라서 이러한 문제를 막기 위한 최소한의 조치가 필요합니다. 

11장의 NodeBird 앱에 여러 패키지를 적용하여 배포를 위한 준비를 해보겠습니다. 

1. morgan과 express-session
현재 익스프레스 미들웨어 중 일부가 개발용으로 설정되어 있습니다. 
이 미들웨어를 배포용으로 설정할 것입니다. 
[app.js]
.....
sequelize.sync({ force: false })
  .then(() => {
    console.log('데이터베이스 연결 성공');
  })
  .catch((err) => {
    console.error(err);
  });

if(process.env.NODE_ENV === 'production') {
  app.use(morgan('combined'));
} else {
  app.use(morgan('dev'));
}

app.use(express.static(path.join(__dirname, 'public')));
.....

=> process.env.NODE_ENV는 배포 환경인지 개발 환경인지를 판단할 수 있는 환경변수입니다.
저는 주로 배포 환경일때는 morgan을 combined 모드로 사용하고, 개발환경일때는 dev모드로 
사용합니다. combined 모드는 dev 모드에 비해 더 많은 사용자 정보를 로그로 남기므로 
추후 버그를 해결할 때 더 유용하게 사용할 수 있습니다.

참고로 pocess.env.NODE_ENV는 .env에 넣을 수 없습니다.
개발 환경인지 배포 환경인지에 따라 값이 변해야 하는데,
.env 파일은 정적 파일이기때문입니다.
NODE_ENV를 동적으로 바꾸는 방법은 cross-env에서 알아봅니다. 

이번에는 express-session을 배포용으로 설정합니다. 
단, express-session은 사용자에 따라 설정할 필요가 없을수도 있습니다. 

[app.js]
.....
app.use(cookieParser(process.env.COOKIE_SECRET));
const sessionOption = {
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
};
if(process.env.NODE_ENV === 'production') {
  sessionOption.proxy = true;
  // sessionOption.cookie.secure = true;
}

app.use(session(sessionOption));
app.use(passport.initialize());
.....

배포 환경일 때는 proxy와 cookie.secure를 true로 바꿉니다. 
하지만 무조건 이렇게 적용해야 하는 것은 아닙니다. 
proxy를 true를 적용해야 하는 경우는 https 적용을 위해 노드 서버 앞에 
다른 서버를 두었을 때 입니다. 
cookie.secure도 https를 적용할 때만 true로 바꿉니다. 

2.시퀄라이즈

데이터베이스도 배포 환경으로 설정합니다. 시퀄라이즈의 경우 수정이 필요합니다. 
시퀄라이즈에서 가장 큰 문제는 비밀번호가 하드 코딩되어 있다는 것이며, 
JSON 파일이므로 변수를 사용할 수 없습니다. 
다행히 시퀄라이즈는 JSON 대신 JS 파일을 설정 파일로 쓸수 있게 지원합니다. 

config폴더에 config.json을 지우고 config.js를 생성합니다. 
[config/config.js]
require('dotenv').config();

module.exports = {
  development: {
    username: 'root',
    password: process.env.SEQUELIZE_PASSWORD,
    database: 'nodebird',
    host: '127.0.0.1',
    dialect: 'mysql',
  },
  test: {
    username: "root",
    password: process.env.SEQUELIZE_PASSWORD,
    database: "nodebird_test",
    host: "127.0.0.1",
    dialect: "mysql"
  },
  production: {
    username: 'root',
    password: process.env.SEQUELIZE_PASSWORD,
    database: 'nodebird',
    host: '127.0.0.1',
    dialect: 'mysql',
    logging: false,
  },
};
=> JS파일이므로 dotenv 모듈을 사용할 수 있습니다. 
예제에서는 password만 process.env로 바꾸었지만, 
보안 규칙에 따라 나머지 정보도 process.env로 바꿔도 됩니다. 
특히 username 속성이나 host 속성은 각각 아이디와 DB 서버 주소 역할을 하므로 
숨기는게 좋습니다. 

process.env가 development일 때는 development 속성의 설정 내용이 적용되고,
production일 때는 production 속성의 설정 내용이 적용됩니다. 
실무에서는 개발용 데이터베이스와 배포용 데이터베이스를 구별하기도 하므로 
이렇게 구분하는 것이 유용합니다. 

지금은 쿼리를 수행할 때 마다 SQL문이 노출됩니다. 
배포 환경에서는 어떤 쿼리가 수행되는지 숨기는 것이 좋습니다. 
따라서 production 일 경우에는 logging에 false를 줘서 
쿼리 명령어를 숨겼습니다. 


데이터 베이스 비밀번호는 .env 파일에 입력합니다. 
[.env]
COOKIE_SECRET = nodebirdsecret
KAKAO_ID=90ac04a1fd368bf09739c98859ab66c0
SEQUELIZE_PASSWORD = 1234

3.cross-env
cross-env 패키지를 사용하면 동적으로 process.env(환경변수)를 변경할 수있다. 
또한 모든 운영체제에서 동일한 방법으로 환경 변수를 변경할 수있게 됩니다. 

[package.json]
{
  "name": "nodebird",
  "version": "0.0.1",
  "description": "익스프레스로 만드는 SNS 서비스",
  "main": "server.js",
  "scripts": {
    "start" : "NODE_ENV=production PORT=80 node server",
    "dev": "nodemon server",
    "test": "jest"
  },
  .....

서버 실행을 위한 npm 스크립트를 두개로 나누었습니다. 
npm start는 배포 환경에서 사용하는 스크립트고, 
npm run dev는 개발 환경에서 사용하는 스크립트입니다. 
npm start시에 실행되는 명령어가 좀 독특합니다. 
앞에 NODE_ENV=production PORT=80이 붙어 있습니다. 
스크립트를 실행할 때 process.env를 동적으로 설정하는 방법입니다. 
process.env.NODE_ENV가 production이 되고, process.env.PORT가 80이 됩니다. 

그런데 이 방식에는 문제가 있습니다 
리눅스나 맥에서는 되지만, 윈도에서는 process.env를 이렇게 설정 할수 없습니다. 

이럴때 cross-env가 사용됩니다. 
npm을 통해 설치합니다. 
$npm i cross-env

다시 package.json 파일을 수정합니다. 
.....
  "scripts": {
    "start" : "cross-env NODE_ENV=production PORT=80 node server",
    "dev": "nodemon server",
    "test": "jest"
  },
.....

앞에 cross-env를 붙임으로써 윈도에서도 실행됩니다. 


4. sanitize-html, csurf
sanitize-html과 csurf 패키지는 각각 XSS(Cross Site Scripting),
CSRF(Cross Site Request Forgery) 공격을 막기 위한 패키지입니다. 

$npm i sanitize-html
$npm i csurf

XSS는 악의적인 사용자가 사이트에 스크립트를 삽입하는 공격입니다. 
악성 사용자가 게시글이나 댓글등을 업로드할 때 자바스크립트가 포함된 태그를 올리면
나중에 다른 사용자가 그 게시글이나 댓글을 볼 때 그 스크립트가 실행되어서 
예기치 못한 동작을 하게 됩니다. 

따라서 서버에서는 사용자가 게시글을 업로드할때 스크립트가 포함되어 있는지 검사해서,
존재한다면 제거해야 합니다. 
다만, 공격성 스크립트 유형이 많으므로 라이브러리의 도움을 받는 것이 좋습니다. 

사용법은 간단합니다. 

const sanitizeHtml = require('sanitize-html);
const html = "<script>location.href = 'https://gilbut.co.kr'</script>";
console.log(sanitizeHtml(html)); //''

사용자가 업로드한 HTML을 sanitize-html 함수로 감싸면 허용하지 않은 태그나 스크립트는
제거됩니다. 두번째 인수로 허용할 부분에 대한 옵션을 넣을 수있는데, 
옵션 목록은 공식 문서를 참고하면 됩니다. 

CSRF는 사용자가 의도치 않게 공격자가 의도한 행동을 하게  만드는 공격입니다. 
예를 들어 특정 페이지에 방문할 때 저절로 로그아웃 되거나, 
게시글이 써지는 현상을 유도할 수 있습니다. 
심지어 은행과 같은 사이트에서는 다른 사람에게 송금하는 행동을 넣는 등 상황에 따라 크게 
악용될 수 있는 공격입니다. 

이 공격을 막으려면 내가 한 행동이 내가 한것이 맞다는 점을 인증해야 합니다. 
이때 CSRF 토큰이 사용되고, cursf 패키지는 이 토큰을 쉽게 발급하거나 검증할 수 있도록 돕습니다.

아래 코드는 공식 문서에서 발췌한 예제입니다. 
GET /form 라우터는 form을 렌더링 하는 라우터이고
POST /form 라우터는 form에서 보낸 데이터를 처리하는 라우터입니다. 

const crsf = require('cursf');
const crsfProtection = crsf({cookie:true});

app.get('/form', crsfProtection, (req, res)=> {
  res.render('crsf', {crsfToken:req.crsfToken()});
});

app.post('/form', crsfProtection, (req, res)=> {
  res.send('ok');
});

익스프레스의 미들웨어 형식으로 동작하며 form과 같은 것을 렌더링할 때 CSRF 토큰을 같이 제공합니다. 
현재 cookie를 사용하는 것으로 옵션을 설정했으므로 cookie-parser 패키지도 연결되어 있어야 합니다. 

토큰은 req.crsfToken()으로 가져올 수 있습니다. 
프런트엔드에 렌더링 된 CSRF 토큰을 나중에 form을 제출할 때 데이터와 함께 제출하면 됩니다. 
상황에 따라 CSRF 토큰을 적용하는 방법이 다른데, 이는 공식 문서를 참고하면 됩니다. 

5. pm2
pm2는 원활한 서버운영을 위한 패키지 입니다. 
'개발할 때는 nodemon을 쓴다면, 배포할 때는 pm2를 쓴다'라는 말이 잇을 정도로 유용합니다. 
가장 큰 기능은 서버가 에러로 인해 꺼졌을 때 서버를 다시 켜주는 것입니다. 

또 하난의 중요한 기느은 바로 멀티 프로세싱입니다. 
멀티 스레딩은 아니지만 멀티 프로세싱을 지원하여 
노드 프로세스 개수를 한 개 이상으로 늘릴 수 있습니다 
기본적으로 CPU 코어를 하나만 사용하는데, 
pm2를 사용해서 프로세스를 여러개 만들면 다른 코어들 까지 사용할 수 있습니다.
클라이언트로부터 요청이 올때 알아서 요청을 여러 노드 프로세스에 고르게 분배합니다. 
하나의 프로세스가 받는 부하가 적어지므로 서비스를 더 원활하게 운영할 수 있습니다. 

단점도 있습니다. 멀티 스레딩이 아니므로 서버의 메모리 같은 자원을 공유하지는 못합니다 
지금 까지 세션을 메모리에 저장했는데, 메모리를 공유하지 못해서 프로세스 간에 
세션이 공유되지 않게 됩니다. 
로그인 후 새로고침을 반복할 때 세션 메모리가 있는 프로세스로 요청이 가면 로그인된 상태가 되고,
세션 메모리가 없는 프로세스로 요청이 가면 로그인 되지 않은 상태가 되는 것입니다. 

이 문제를 극복하기 위해서는 세션을 공유할 수 있게 해주는 무언가가 필요합니다. 
이를 위해 주로 멤캐시드나 레디스 같은 서비스를 사용합니다. 
레디스로 세션을 공유하는 방법은 15.1.8절에서 알아봅니다. 

NodeBird 앱 폴더에서 콘솔을 실행한 후 pm2를 설치 합니다. 
$npm i pm2

pm2는 nodemon처럼 콘솔에 입력하는 명령어입니다. 
package.json을 수정합니다. 
nodemon대신 pm2를 쓰도록 npm start 스크립트를 수정할 것입니다. 

[package.json]
{
  "name": "nodebird",
  "version": "0.0.1",
  "description": "익스프레스로 만드는 SNS 서비스",
  "main": "server.js",
  "scripts": {
    "start": "cross-env NODE_ENV=production PORT=80 pm2 start server.js",
    "dev": "nodemon server",
    "test": "jest"
  },

  ........
start 스크립트에 node sercer 대신에 pm2 start server.js를 입력했습니다. 
pm2로 스크립트를 실행하는 명령어입니다. 

이제 바뀐 명령어를 실행해 보겠습니다. 
$npm start


                        -------------

__/\\\\\\\\\\\\\____/\\\\____________/\\\\____/\\\\\\\\\_____
 _\/\\\/////////\\\_\/\\\\\\________/\\\\\\__/\\\///////\\\___
  _\/\\\_______\/\\\_\/\\\//\\\____/\\\//\\\_\///______\//\\\__
   _\/\\\\\\\\\\\\\/__\/\\\\///\\\/\\\/_\/\\\___________/\\\/___
    _\/\\\/////////____\/\\\__\///\\\/___\/\\\________/\\\//_____
     _\/\\\_____________\/\\\____\///_____\/\\\_____/\\\//________
      _\/\\\_____________\/\\\_____________\/\\\___/\\\/___________
       _\/\\\_____________\/\\\_____________\/\\\__/\\\\\\\\\\\\\\\_
        _\///______________\///______________\///__\///////////////__


                          Runtime Edition

        PM2 is a Production Process Manager for Node.js applications
                     with a built-in Load Balancer.

                Start and Daemonize any application:
                $ pm2 start app.js

                Load Balance 4 instances of api.js:
                $ pm2 start api.js -i 4

                Monitor in production:
                $ pm2 monitor

                Make pm2 auto-boot at server restart:
                $ pm2 startup

                To go further checkout:
                http://pm2.io/


                        -------------

[PM2] Spawning PM2 daemon with pm2_home=C:\Users\오세웅\.pm2
[PM2] PM2 Successfully daemonized
[PM2] Starting C:\Users\오세웅\Coding Place\nodejs\chapter15_AWS,GCP\server.js in fork_mode (1 instance)
[PM2] Done.
┌─────┬───────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id  │ name      │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├─────┼───────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ 0   │ server    │ default     │ 0.0.1   │ fork    │ 11528    │ 0s     │ 0    │ online    │ 0%       │ 36.9mb   │ 오세웅      │ disabled │
└─────┴───────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘

NOTE> 리눅스나 맥에서 pm2 실행 시
리눅스나 맥에서 pm2를 실행할 때 1024번 이하의 포트를 사용하려면 관리자 권한이 필요합니다. 
따라서 sudo를 명령어 앞에 붙여 실행합니다.
앞으로 나오는 다른 명령어도 sudo npm start, sudo npx list, 
sudo npx pm2 kill, sudo npx pm2 monit처럼 하면 됩니다. 


pm2를 실행했더니 다른 점이 있습니다. 
node나 nodemon 명령어와는 다르게 노드 프로세스가 실행된 후에 
콘솔에 다른 명ㄹ여어를 입력할 수 있습니다. 
pm2가 노드 프로세스를 백그라운드로 돌리므로 가능한것입니다. 

백그라운드에서 돌고 있는 노드 프로세스를 확인할 방법이 필요한데 
npx pm2 list 명령어를 사용하면 됩니다. 

$npx pm2 list

npm start를 실행했을 때 처럼 현재 프로세스 정보가 표시됩니다. 
프로세스 아이디(pid), CPU와 메모리 사용량(mem)등이 보여 편리합니다. 
uptime과 status 사이에 재시작된 회수가 나오는데 0이 아니라면
재부팅된 적이 있따는 것을 의미합니다. 
이 경우에는 왜 재시작되었는지 확인해봐야 합니다. 
npx pm2 logs로 로그를 확인할 수 있습니다. 
에러 로그만 보고 싶다면 뒤에 -err을 붙이면 됩니다. 
출력 줄 수를 바꾸고 싶다면 --lines 숫자 옵션을 사용합니다. 

나중에 pm2 프로세스를 종료하고 싶다면 콘솔에 npx pm2 kill을 입력하면 됩니다. 
서버를 재 시작하고 싶다면 npx pm2 reload all을 입력합니다.
다운타임(서버가 중지되어 클라이언트가 접속할 수 없는 시간)이 거의 없이 
서저가 재시작되어 좋습니다 

노드의 cluster 모듈처럼 클러스터링을 가능하게 하는 pm2의 클러스터링 모드를 사용해 봅시다. 

[package.json]
{
  "name": "nodebird",
  "version": "0.0.1",
  "description": "익스프레스로 만드는 SNS 서비스",
  "main": "server.js",
  "scripts": {
    "start": "cross-env NODE_ENV=production PORT=80 pm2 start server.js -i 0",
    "dev": "nodemon server",
    "test": "jest"
  },
  "author"
........

pm2 start app.js대신 pm2 start app.js -i 0명령어를 사용합니다.
취향에 따라 pm2 start app.js -i -1도 많이 사용합니다. 
-i 뒤에 생성하길 원하는 프로세스 개수를 기입하면 됩니다. 
0은 현재 CPU 코어 개수만큼 프로세스를 생성한다는 뜻이고,  
-1은 프로세스를 CPU 코어개수보다 한 개 덜 생성하겠다는 뜻입니다. 
예제에서는 -i 0을 사용합니다. 

npm pm2 kill로 서버를 종료한 뒤 변경된 명령어를 사용해 봅시다. 
&&를 사용해 여러개이 명령어를 연달아 실행할 수 있습니다. 

$npx pm2 kill && npm start

실제 서버 운영시 서비스 규모가 커질수록 비용이 발생할 가능성이 커지므로 놀고 있는 코어까지
클러스터링으로 작동하게 하는 것이 비용을 절약하는 길입니다. 
하지만 프로세스 간에 메모리를 공유하지 못하는 문제도 있으므로 최대한 프로세스 간에 
공유하는 것 (세션등)이 없도록 설계해야 합니다. 
공유해야 하는 데이터가 있다면 데이터베이스를 사용해야 합니다 

6. winston
실제 서버를 운영할 때 console.log, console.error를 대체하기 위한 모듈입니다. 
console.log, console.error를 사용하면 개발 중에는 편리하게 서버의 상황을 파악할 수 
있지만, 실제 배포 시에는 사용하기 어렵습니다. 
console 객체의 메서드들이 언제 호출 되었는지 파악하기 힘들 뿐만 아니라 서버가 종료되는 
순간 로그들도 사라지기 때문입니다. 
에러가 발생하면 에러 메시지를 확인해야 하는데, 
서버가 종료되어 에러 메시지들이 날아가버리는 황당한 일이 일어나게 됩니다. 
이와 같은 상황을 방지하려면 로그를 파일이나 다른 데이터베이스에 저장해야 합니다. 
이때 winston을 사용합니다. 

winston을 설치하고 사용방법을 간단히 알아보겠습니다. 
너무나 다먕한 방식으로 활용할 수 있어 기본적인 것만 살펴봅니다. 

$npm i winston

winston을 설치한 뒤, logger.js를 작성합니다. 
[logger.js]
'use strict';

const { createLogger, format, transports} = require('winston');

const logger = createLogger({
    level : 'info',
    format : format.json(),
    transports : [
        new transports.File({filename : 'combined.log'}),
        new transports.File({filename: 'error.log', level:'error'}),
    ],
});

if(process.env.NODE_ENV !== 'production') {
    logger.add(new transports.Console({format:format.simple()}));
}

module.exports = logger;

winston패키지의 createLogger 메서드로 logger를 만듭니다. 
인수로 logger에 대한 설정을 넣어줄 수 있습니다. 
설정으로는 level, foramt, transports 등이 있습니다. 
1.level
level은 로그의 심각도를 의미합니다. 
error, warn, info, verbose, debug, silly가 있습니다. 
심가도순(error가 가장 심각)이므로 위 순서를 참고하여 기록하길 원하는 
유형의 로그를 고르면 됩니다.
info를 고른 경우, info보다 심각한 단계의 로그(error,warn)도 함께 기록됩니다. 

2.format
format은 로그의 형식입니다. 
json, label, timestamp, printf, simple, combine등의 다양한 형식이 있습니다. 
기본적으로 JSON 형식으로 기록하지만, 
로그 기록 시간을 표시하려면 timestamp를 쓰는 것이 좋습니다. 
combine은 여러 형식을 혼합해서 사용할 때 씁니다. 
활용법이 다양하므로 공식 문서를 참고하시기 바랍니다. 

3.transports
transports는 로그 저장 방식을 의미합니다. 
new transports.File은 파일로 저장한다는 뜻이고,
new transports.Console은 콘솔에 출력한다는 뜻입니다. 
여러 로깅 방식을 동시에 사용할 수도 있습니다. 
배포 환경이 아닌 경우 파일 뿐만 아니라 콘솔에도 출력하도록 되어 있습니다. 
이 메서드들에도 level, format 등을 설정할 수 있습니다. 
new transports.File인 경우에는 로그 파일의 이름인 filename도 설정할 수 있습니다. 

이렇게 logger 객체를 만들어 다른 파일에서 사용하면 됩니다. 
info, warn, error 등의 메서드를 사용하면 해당 심각도가 적용된 로그가 기록됩니다. 

[app.js]
.....
dotenv.config();
const pageRouter = require('./routes/page');
const authRouter = require('./routes/auth');
const postRouter = require('./routes/post');
const userRouter = require('./routes/user');
const { sequelize } = require('./models');
const passportConfig = require('./passport');
const logger = require('./logger');
.....
app.use(session(sessionOption));
app.use(passport.initialize());
app.use(passport.session());

app.use('/', pageRouter);
app.use('/auth', authRouter);
app.use('/post', postRouter);
app.use('/user', userRouter);

app.use((req, res, next) => {
  const error =  new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  logger.info('hello');
  logger.error(error.message);
  next(error);
});
.....

npm run dev 명령어로 개발용 서버를 실행한 후 http://localhost:8001/abcd에 접속해봅시다. 
없는 주소이므로 404 Not Found 에러가 발생합니다. 

nodebird 폴더에 생성된 로그르 살표봅시다. 
[combined.log]
{"level":"info","message":"hello"}
{"level":"error","message":"GET /abcd 라우터가 없습니다."}
{"level":"info","message":"hello"}
{"level":"error","message":"GET /favicon.ico 라우터가 없습니다."}

[error.log]
{"level":"error","message":"GET /abcd 라우터가 없습니다."}
{"level":"error","message":"GET /favicon.ico 라우터가 없습니다."}

info 이상 단계의 모든 로그를 기록하도록 되어 있는 combined.log 파일에는
info와 error 단계의 로그가 저장되었습니다. 
error 단계의 로그만 기록하도록 되어 있는 error.log 에는 error 단계의 로그만
저자되어 있습니다. 
이렇게 로그를 콘솔에만 출력하는 것이 아니라, 
파일로도 저장할 수 있어 실제 서비스를 운영할 때 유용합니다 

이책에서는 설명하지 않지만, winston-daily-rotate-file이라는 패키지도 있습니다. 
로그를 날짜별로 관리할 수 있게 해주는 패키지라 알아두면 좋습니다 
winston과 함께 사용하는 방법은 winston 공식 문서에 나와있습니다. 
https://github.com/winstonjs/winston

7. helmet, hpp
서버의 각종 취약점을 보완해주는 패키지들이며, 익스프레스 미들웨어로서 사용할 수 있습니다. 
이 패키지들을 사용한다고 해서 모든 취약점을 방어해주는 것은 아니므로 서버를 운영할 때는
주기적으로 취약점을 점검해야 합니다. 

$npm i helmet hpp

개발 환경에서는 사용할 필요가 없으므로 배포 환경일 때만 적용하면 됩니다. 

helmet과 hpp가 방어해주는 취약점 목록은 각각의 공식문서에 나와 있습니다. 
기본적으로는 배포 전에 이 두 패키지를 넣어주는 것이 좋습니다. 
다만, 때로는 너무 보안 규칙을 엄격하게 적용해서 방해되는 경우도 있으니, 
공식 문서를 보면서 필요없는 옵션은 해제해야 합니다. 

8. connect-redis
멀티 프로세스 간 세션 공유를 위해 리디스와 익스프레스를 연결해주는 패키지입니다. 
기존에는 로그인할 때 express-session의 세션 아이디와 실제 사용자 정보가 메모리에 저장됩니다. 
따라서 서버가 종료되어 메모리가 날아가면 접속자들의 로그인이 모두 풀려버립니다. 
Waining : connect.session() MemoryStore is not designed for a production
environment, as it will leak memory, and will not scale past a single process
라는 경고 메시지도 발생합니다. 

이를 해결하기 위해 세션 아이디와 실제 사용자 정보를 데이터베이스에 저장합니다. 
이때 사용하는 데이터베이스가 레디스입니다. 
다른 데이터베이스를 사용해도 되지만 주로 레디스를 많이 사용합니다. 
메모리 기반의 데이터베이스라서 성능이 우수 하기 때문입니다. 

$npm i redis connect-redis

레디스를 사용하려면 connect-redis 패키지 뿐만 아니라 레디스 데이터베이스를 
설치해야 합니다. 
서버에 직접 설치 할 수도 있지만, 레디스를 호스팅해주는 서비스를 쓰는 것이 편리합니다. 
바로 redislabs 입니다. 
redislabs 웹 사이트 (http://redislabs.com/)에 접속합니다. 

Public endpoint와 Redis Password를 복사해 .env 에 붙여 넣습니다. 
이때 endpoint에서 host와 port를 분리합니다. 

[app.js]
.....
const passport = require('passport');
const helmet = require('helmet');
const hpp = require('hpp');
const redis = require('redis');
const RedisStore = require('connect-redis')(session);

dotenv.config();
const redisClient = redis.createClient({
  url: `redis://${process.env.REDIS_HOST}:${process.env.REDIS_PORT}`,
  password: process.env.REDIS_PASSWORD,
});
.....
const sessionOption = {
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
  store: new RedisStore({ client: redisClient }),
};
.........

connect-redis 패키지로부터 RedisStore 객체를 require 합니다.
이때 session 을 인수로 넣어서 호출하는 것을 잊지 마세요. 
connect-redis는 express-session에 의존성이 있습니다. 

redis패키지의 createClient 메서드로 redisClient 객체를 생성합니다. 
이때 url과 password 속성에 접속 정보를 입력합니다. 
여기서 dotenv.config() 보다 코드가 아래에 있어야 한다는 점에 주의하세요.
.env 파일에 적힌 process.env 객체의 값들은 dotenv.config() 이후에 생성됩니다. 
https://www.daleseo.com/js-dotenv/

express-session 미들웨어에는 store 옵션을 추가합니다. 
기본적으로는 메모리에 세션을 저장하지만, 이제는 RedisStore에 저장합니다.
RedisStore의 옵션으로 client 속성에 redisClient객체를 연결하면 됩니다. 

이제 세ㅕㄴ 정보가 메모리 대신 레디스에 저장됩니다. 따라서 로그인 후 서버를 껐다 켜도
로근인 유지됩니다. 실제 서비스에서 서버 업데이트 시 로그인이 풀리는 현상을 
막을 수 있습니다. 

NOTE>> express-rate-limit
express-rate-limit 패키지도 사용량을 메모리에 기록하므로 서버를 재 시작하면
사용량이 초기화 됩니다. 
따라서 이것도 레디스에 기록하는 것이 좋습니다. 
rete-limit-redis라는 패키지와 express-rate-limit 패키지를 같이 사용하면 됩니다. 

9. vnm, n 
노드 버전을 업데이트 하기 위한 패키지입니다. 
윈도에서는 nvm-installer를 사용하고,
리눅스나 맥에서는 n  패키지를 사용합니다. 

1)윈도
윈도에서는 https://github.com/coreybutler/nvm-windows/releases에 접속하여
nvm-setup.zip를 내려받습니다. 내려받은 파일을 압축 해제 한 후 실행시켜 설치합니다. 

이제 콘솔에 nvm 명령어를 입력할 수 있습니다. 
설치된 노드 버전을 확인하는 명령어는 nvm list입니다. 

새로운 버전을 설치하고 싶다면 nvm install [버전]을 입력합니다. 
nvm install 14.1.0처럼 특정 버전을 입력하거나
nvm install latest 처럼 최신 버전을 설치하게 되면 됩니다. 

설치된 버전을 사용하려면 nvm use [버전명]을 입력합니다. 


*****2. 깃과 깃허브 사용하기 *****

1. 깃 설치하기
먼저 깃을 설치해봅시다. 
https://git-scm.com/download 에 접속하여 각자의 운영체제에 맞게 내려받습니다. 

설치가 완료된 후, 깃이 제대로 설치되었는지 확인해보겠습니다. 
콘솔에서 다음 명령어를 입력합니다. 
C:\Users\오세웅>git --version
git version 2.33.0.windows.2

깃의 버전을 확인하는 명령어 입니다. 버전이 제대로 표시된다면 설치에 성공한 것입니다. 
이제 소스 코드를 깃에 추가할 것입니다. 
그런데 node-modules, uploads 디렉터리는 자동생성되므로 추가할 필요가 없습니다. 
마찬가기 이유로 winston 로그도 굳이 깃을 통해 관리할 필요가 없습니다. 
따라서 이를 추가하지 않겠다고 깃에게 알려야 합니다. 
이때 .gitignore 파일이 사용됩니다. 
NodeBird 프로젝트 폴더에 .gitignore파일을 생성합니다. 

[.gitignore]
node-modules
uploads
*.log
coverage

위와 같이 깃에 추가하지 않을 폴더 또는 파일을 한 줄씩 적으면 됩니다. 
*.log 처럼 와일드카드(*)를 사용할 수도 있습니다. 
그러면 Log 확장자를 가진 모든 파일을 깃이 관리하지 않게 됩니다. 

NOTE>> .env
실제 서비스에서는 .env 파일도 깃에 추가하지 말아야 합니다. 
깃에 추가하면 .env에 적어둔 비밀 키가 모두 기록되어버리기 때문입니다. 
배포용 서버에는 직접 .env 파일을 생성하여 비밀키를 적어주는 것이 바람직합니다. 
이 예제에서는 편의를 위해 .env 파일도 깃에 추가하겠습니다. 
하지만 실제 서비스에서는 편의보다 보안이 더 중요하다는 것을 잊지 마세요. 

2.깃 허브 사용하기
깃을 사용하기에 앞서 깃허브도 사용해보겠습니다. 
깃 허브는 기업의 서비스이므로 사용하려면 회원가입이 필요합니다. 

